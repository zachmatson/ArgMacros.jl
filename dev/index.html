<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Guide · ArgMacros</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">ArgMacros</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Guide</a><ul class="internal"><li><a class="tocitem" href="#Why-ArgMacros?"><span>Why ArgMacros?</span></a></li><li><a class="tocitem" href="#Installation"><span>Installation</span></a></li><li><a class="tocitem" href="#Argument-Format-Types"><span>Argument Format Types</span></a></li><li><a class="tocitem" href="#Adding-Arguments"><span>Adding Arguments</span></a></li><li><a class="tocitem" href="#Using-Argument-Values"><span>Using Argument Values</span></a></li><li><a class="tocitem" href="#Validating-Arguments"><span>Validating Arguments</span></a></li><li><a class="tocitem" href="#Adding-Help"><span>Adding Help</span></a></li><li><a class="tocitem" href="#Leftover-Arguments"><span>Leftover Arguments</span></a></li><li><a class="tocitem" href="#Taking-Argument-Code-out-of-Main-Function"><span>Taking Argument Code out of Main Function</span></a></li><li><a class="tocitem" href="#Calling-a-Julia-Script-With-Arguments"><span>Calling a Julia Script With Arguments</span></a></li></ul></li><li><a class="tocitem" href="macros/">Available Macros</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Guide</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Guide</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/zachmatson/ArgMacros.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Guide"><a class="docs-heading-anchor" href="#Guide">Guide</a><a id="Guide-1"></a><a class="docs-heading-anchor-permalink" href="#Guide" title="Permalink"></a></h1><p>This page will offer an introduction on using ArgMacros to read command-line arguments. Reading through this before using the package is recommended.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Version 0.2.x of ArgMacros might be rough around some edge cases.  Make sure to test the interface you build before using it. If you notice any issues or want to request new features, create an issue on <a href="https://github.com/zachmatson/ArgMacros.jl">GitHub</a></p></div></div><h2 id="Why-ArgMacros?"><a class="docs-heading-anchor" href="#Why-ArgMacros?">Why ArgMacros?</a><a id="Why-ArgMacros?-1"></a><a class="docs-heading-anchor-permalink" href="#Why-ArgMacros?" title="Permalink"></a></h2><p>ArgMacros is designed for parsing arguments in command-line Julia scripts. Compilation time is the greatest bottleneck for startup of scripts in Julia, and is mostly unavoidable. ArgMacros provides quick parsing after compilation while ensuring compilation time fast too.</p><p>ArgMacros also provides convenience when writing scripts by offering various and easily interchangeable formats for outputting parsed arguments, a simple interface, and guaranteed type safety of parsed arguments. Some output formats also provide static typing of the argument variables.</p><h2 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h2><p>Install ArgMacros using Julia&#39;s Pkg package manager. Enter the Pkg prompt by typing <code>]</code> at the REPL and then install:</p><pre><code class="language-julia-repl">(@v1.5) pkg&gt; add ArgMacros</code></pre><p>Then load ArgMacros into your script with <code>using ArgMacros</code>.</p><h2 id="Argument-Format-Types"><a class="docs-heading-anchor" href="#Argument-Format-Types">Argument Format Types</a><a id="Argument-Format-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Argument-Format-Types" title="Permalink"></a></h2><p>There are four formats for your program or script to receive the parsed arguments with ArgMacros, all of which use the same interface for argument declaration:  </p><ul><li>Inline, typed local variables (<a href="macros/#ArgMacros.@inlinearguments"><code>@inlinearguments</code></a>)</li><li>An automatically generated custom <code>struct</code> type (<a href="macros/#ArgMacros.@structarguments"><code>@structarguments</code></a>)</li><li><code>NamedTuple</code> (<a href="macros/#ArgMacros.@tuplearguments"><code>@tuplearguments</code></a>)</li><li><code>Dict</code> (<a href="macros/#ArgMacros.@dictarguments"><code>@dictarguments</code></a>)</li></ul><h2 id="Adding-Arguments"><a class="docs-heading-anchor" href="#Adding-Arguments">Adding Arguments</a><a id="Adding-Arguments-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-Arguments" title="Permalink"></a></h2><p>All arguments must be declared using the macros provided, and all of the declarations must exist within the <a href="macros/#ArgMacros.@inlinearguments"><code>@inlinearguments</code></a> block, or other argument macro block, like so:</p><pre><code class="language-julia">@inlinearguments begin
    *arguments go here*
end</code></pre><p>The types of arguments supported are broken down into two categories:</p><ul><li>Options (<code>@argument...</code>) - Marked with flags<ul><li><a href="macros/#ArgMacros.@argumentrequired"><code>@argumentrequired</code></a></li><li><a href="macros/#ArgMacros.@argumentdefault"><code>@argumentdefault</code></a></li><li><a href="macros/#ArgMacros.@argumentoptional"><code>@argumentoptional</code></a></li><li><a href="macros/#ArgMacros.@argumentflag"><code>@argumentflag</code></a></li><li><a href="macros/#ArgMacros.@argumentcount"><code>@argumentcount</code></a></li></ul></li><li>Positionals (<code>@positional...</code>) - Identified by position in argument list<ul><li><a href="macros/#ArgMacros.@positionalrequired"><code>@positionalrequired</code></a></li><li><a href="macros/#ArgMacros.@positionaldefault"><code>@positionaldefault</code></a></li><li><a href="macros/#ArgMacros.@positionaloptional"><code>@positionaloptional</code></a></li></ul></li></ul><p>The arguments are either required, optional, or have default values, as is evident in their names. Additionally, <a href="macros/#ArgMacros.@argumentflag"><code>@argumentflag</code></a> checks the presence of a flag, and <a href="macros/#ArgMacros.@argumentcount"><code>@argumentcount</code></a> counts how many times a flag appears. Most of the argument types require specifying a type and a local variable name, while options also require flag(s) to be specified, and default arguments require their default value to be specified.</p><p>Parsing is carried out by fetching values for the options first, then the positional arguments. Values will be fetched in the order that arguments are declared.  For this reason, ALL options must be declared before ANY positionals, required  positionals must be declared before default/optional ones, and positional arguments must be declared in the order the user is expected to enter them.</p><p>You should make your argument types <code>Symbol</code>, <code>String</code>, or subtypes of <code>Number</code>.</p><p>Here is an example with some arguments:</p><pre><code class="language-julia">@inlinearguments begin
    @argumentrequired String foo &quot;-f&quot; &quot;--foo&quot;
    @argumentdefault String &quot;lorem ipsum&quot; bar &quot;--bar&quot;
    @argumentflag verbose &quot;-v&quot;
    @positionalrequired String input &quot;input_file&quot;
    @positionaloptional String output &quot;output_file&quot;
end</code></pre><p>As you can see, options allow using long option names, short option names, or both. <a href="macros/#ArgMacros.@argumentcount"><code>@argumentcount</code></a> is a special case and only allows a single long or short name to be given. Positionals allow an optional &quot;help name&quot; to be specified, which is presented to the user instead of the name of local variable they will be stored in.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The ordering rules for argument declarations should be enforced at compile time, but making sure to follow them is essential to your code running properly. Additionally, make sure not to declare multiple arguments using the same flags. Other than the reserved <code>-h</code> and <code>--help</code> flags, this will not be detected automatically at compile time, and could lead to undefined behavior. </p></div></div><h2 id="Using-Argument-Values"><a class="docs-heading-anchor" href="#Using-Argument-Values">Using Argument Values</a><a id="Using-Argument-Values-1"></a><a class="docs-heading-anchor-permalink" href="#Using-Argument-Values" title="Permalink"></a></h2><p>Once an argument is decalred, you can be sure it holds a value of the correct type. <a href="macros/#ArgMacros.@argumentoptional"><code>@argumentoptional</code></a> and <a href="macros/#ArgMacros.@positionaloptional"><code>@positionaloptional</code></a> will use the type <code>Union{T, Nothing}</code>, however, and may also contain <code>nothing</code>. <a href="macros/#ArgMacros.@argumentflag"><code>@argumentflag</code></a> uses <code>Bool</code> and <a href="macros/#ArgMacros.@argumentcount"><code>@argumentcount</code></a> uses <code>Int</code>. The other macros will all store the type specified.  </p><p>How exactly you use the values depends on the format used, the following will demonstrate the same arguments with each of the available formats, and some of the consequences of each of them:</p><h3 id="Inline-([@inlinearguments](@ref))"><a class="docs-heading-anchor" href="#Inline-([@inlinearguments](@ref))">Inline (<a href="macros/#ArgMacros.@inlinearguments"><code>@inlinearguments</code></a>)</a><a id="Inline-([@inlinearguments](@ref))-1"></a><a class="docs-heading-anchor-permalink" href="#Inline-([@inlinearguments](@ref))" title="Permalink"></a></h3><p>The arguments are stored directly in local variables, which are statically typed. You can use them immediately without any other boilerplate, but must respect the variable types. These variables, because they are typed, must always be in local scope. You cannot put this block in a global scope.</p><pre><code class="language-julia">function main()
    @inlinearguments begin
        @positionalrequired Int x
        @positionaldefault Int 5 y
        @positionaloptional Int z
    end

    println(x + y) # Prints x + y, the variable names are available right away and must be Ints
    println(isnothing(z)) # z might be nothing, because it was optional
    z = nothing # It is fine to store values of type Nothing or Int in z now
    z = 8
    x = 5.5 # Raises an error, x must hold Int values
    y = nothing # Raises an error, only optional arguments can hold nothing
end</code></pre><h3 id="Custom-struct-([@structarguments](@ref))"><a class="docs-heading-anchor" href="#Custom-struct-([@structarguments](@ref))">Custom <code>struct</code> (<a href="macros/#ArgMacros.@structarguments"><code>@structarguments</code></a>)</a><a id="Custom-struct-([@structarguments](@ref))-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-struct-([@structarguments](@ref))" title="Permalink"></a></h3><p>A new <code>struct</code> type is created to store the arguments, and you can decide if it will be mutable.   The zero-argument constructor function for the new type parses the arguments when it is called.   You must <em>declare</em> the arguments in global scope due to the rules for type declarations, but the constructor can be used anywhere.</p><p>The fields of the struct will all be typed.</p><pre><code class="language-julia"># Declare mutable type Args and the arguments it will hold
@structarguments true Args begin
        @positionalrequired Int x
        @positionaldefault Int 5 y
        @positionaloptional Int z
end

function main()
    args = Args() # The arguments are parsed here

    println(args.x + args.y) # Prints x + y, the variables must be Ints
    println(isnothing(args.z)) # z might be nothing, because it was optional
    
    # These assignemnt operations would all fail if we made Args immutable instead
    args.z = nothing # It is fine to store values of type Nothing or Int in z now
    args.z = 8
    args.x = 5.5 # Raises an error, x must hold Int values
    args.y = nothing # Raises an error, only optional arguments can hold nothing
end</code></pre><h3 id="NamedTuple-([@tuplearguments](@ref))"><a class="docs-heading-anchor" href="#NamedTuple-([@tuplearguments](@ref))"><code>NamedTuple</code> (<a href="macros/#ArgMacros.@tuplearguments"><code>@tuplearguments</code></a>)</a><a id="NamedTuple-([@tuplearguments](@ref))-1"></a><a class="docs-heading-anchor-permalink" href="#NamedTuple-([@tuplearguments](@ref))" title="Permalink"></a></h3><p>A <code>NamedTuple</code> is returned containing all of the argument values, keyed by the variable names given. You can use this version from any scope. All of the fields are typed, and as a <code>NamedTuple</code> the returned object will be immutable.</p><pre><code class="language-julia">function main()
    args = @tuplearguments begin
        @positionalrequired Int x
        @positionaldefault Int 5 y
        @positionaloptional Int z
    end

    println(args.x + args.y) # Prints x + y, the variables must be Ints
    println(isnothing(args.z)) # z might be nothing, because it was optional
    
    # These assignemnt operations will fail because NamedTuples are always immutable
    args.z = nothing
    args.z = 8

    args.x == 5.5 # Can never be true, args.x is guaranteed to be an Int
    isnothing(args.y) # Must be false, y is not optional
end</code></pre><h3 id="Dict-([@dictarguments](@ref))"><a class="docs-heading-anchor" href="#Dict-([@dictarguments](@ref))"><code>Dict</code> (<a href="macros/#ArgMacros.@dictarguments"><code>@dictarguments</code></a>)</a><a id="Dict-([@dictarguments](@ref))-1"></a><a class="docs-heading-anchor-permalink" href="#Dict-([@dictarguments](@ref))" title="Permalink"></a></h3><p>A <code>Dict{Symbol, Any}</code> is returned containing all of the argument variables, keyed by the argument names as <em><code>Symbol</code>s</em>. You can use this version from any scope. The <code>Dict</code> type is mutable, and any type can be stored in any of its fields. Therefore, this version does not provide as strong of a guarantee about types to the compuler when argument values are used later. However, the values will always be of the correct types when the <code>Dict</code> is first returned.</p><pre><code class="language-julia">function main()
    args = @dictarguments begin
        @positionalrequired Int x
        @positionaldefault Int 5 y
        @positionaloptional Int z
    end

    println(args[:x] + args[:y]) # Prints x + y, the variable names are available right away and must be Ints at first
    println(isnothing(args[:z])) # z might be nothing, because it was optional
    args[:z] = nothing # It is fine to store values of any type in z now
    args[:z] = 8
    args[:x] = 5.5 # Same for x
    args[:y] = nothing # And y
    args[:a] = &quot;some string&quot; # New entries can even be added later, of any type
end</code></pre><h2 id="Validating-Arguments"><a class="docs-heading-anchor" href="#Validating-Arguments">Validating Arguments</a><a id="Validating-Arguments-1"></a><a class="docs-heading-anchor-permalink" href="#Validating-Arguments" title="Permalink"></a></h2><p>Perhaps you want to impose certain conditions on the values of an argument beyond its type. You can use the <a href="macros/#ArgMacros.@argtest"><code>@argtest</code></a> macro, which will exit the program if a specified unary predicate returns <code>false</code> for the argument value.</p><p>If using an operator function, make sure to enclose it in parentheses so it is passed to the  macro as a separate expression from the first argument.</p><pre><code class="language-julia">@inlinearguments begin
    ...
    @positionalrequired String input &quot;input_file&quot;
    @argtest input isfile &quot;The input must be a valid file&quot; # Confirm that the input file really exists
    ...
end</code></pre><h2 id="Adding-Help"><a class="docs-heading-anchor" href="#Adding-Help">Adding Help</a><a id="Adding-Help-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-Help" title="Permalink"></a></h2><p>ArgMacros also allows you to create a help screen, accessed by the <code>-h</code> or <code>--help</code> flags. A listing of arguments and their types is created by default, but usage information,  a description, an epilog, and individual argument descriptions can be specified too using the appropriate macros. When using the <a href="macros/#ArgMacros.@arghelp"><code>@arghelp</code></a> macro, note that it always applies to the last argument declared BEFORE the macro is used. The <a href="macros/#ArgMacros.@helpusage"><code>@helpusage</code></a> will prepend your usage text with &quot;Usage: &quot;, so do not include this in the string you pass.</p><p>It is recommended to place <a href="macros/#ArgMacros.@helpusage"><code>@helpusage</code></a>, <a href="macros/#ArgMacros.@helpdescription"><code>@helpdescription</code></a>, and <a href="macros/#ArgMacros.@helpepilog"><code>@helpepilog</code></a> in that order at the beginning of the <code>@...arguments</code> block, but this is not a requirement.</p><pre><code class="language-julia">@inlinearguments begin
    @helpusage &quot;example.jl input_file [output_file] [-f | --foo] [--bar] [-v]&quot;
    @helpdescription &quot;&quot;&quot;
        Lorem ipsum dolor sit amet, consectetur adipiscing elit.
        Praesent eu auctor risus. Morbi a nisl nisi.
        Ut at lorem non lorem accumsan auctor. Class aptent taciti
        sociosqu ad litora torquent per conubia nostra, per inceptos
        himenaeos. Aenean ornare ultrices tellus quis convallis.
        &quot;&quot;&quot;
    @helpepilog &quot;© 2020&quot;
    ...
    @positionalrequired String input &quot;input_file&quot;
    @argtest input isfile &quot;The input must be a valid file&quot;
    @arghelp &quot;The name of the file to be taken as input.&quot;
    ...
end</code></pre><h2 id="Leftover-Arguments"><a class="docs-heading-anchor" href="#Leftover-Arguments">Leftover Arguments</a><a id="Leftover-Arguments-1"></a><a class="docs-heading-anchor-permalink" href="#Leftover-Arguments" title="Permalink"></a></h2><p>By default, the program will exit and print a warning if more arguments are given than the program declares. If you don&#39;t want this to happen, include the <a href="macros/#ArgMacros.@allowextraarguments"><code>@allowextraarguments</code></a> macro.</p><p>This can occur anywhere inside the <code>@...arguments</code> block, but the recommended placement is at the end, after all other help, test, and argument declarations.</p><pre><code class="language-julia">@inlinearguments begin
    ...
    @allowextraarguments
end</code></pre><h2 id="Taking-Argument-Code-out-of-Main-Function"><a class="docs-heading-anchor" href="#Taking-Argument-Code-out-of-Main-Function">Taking Argument Code out of Main Function</a><a id="Taking-Argument-Code-out-of-Main-Function-1"></a><a class="docs-heading-anchor-permalink" href="#Taking-Argument-Code-out-of-Main-Function" title="Permalink"></a></h2><p>It may be preferable, in some cases, not to declare all of your arguments and help information inside of your main function. In this case, the <a href="macros/#ArgMacros.@inlinearguments"><code>@inlinearguments</code></a> block can be enclosed in a macro:</p><pre><code class="language-julia">macro handleargs()
    return esc(quote
        @inlinearguments begin
            ...
        end
    end)
end

function main()
    @handleargs
    ...
    # The argument values will be available here
end</code></pre><p>The other formats provide more flexibility. The argument code for <a href="macros/#ArgMacros.@tuplearguments"><code>@tuplearguments</code></a> and <a href="macros/#ArgMacros.@dictarguments"><code>@dictarguments</code></a> can be placed anywhere, including in a separate function which returns their result. <a href="macros/#ArgMacros.@structarguments"><code>@structarguments</code></a> requires that you declare your arguments in the global namespace (not inside a function, loop, or <code>let</code> block), but this will automatically produce the zero-argument constructor function that you can then call wherever you like.</p><h2 id="Calling-a-Julia-Script-With-Arguments"><a class="docs-heading-anchor" href="#Calling-a-Julia-Script-With-Arguments">Calling a Julia Script With Arguments</a><a id="Calling-a-Julia-Script-With-Arguments-1"></a><a class="docs-heading-anchor-permalink" href="#Calling-a-Julia-Script-With-Arguments" title="Permalink"></a></h2><p>To call a Julia script with arguments from your terminal, run</p><pre><code class="language-text">$ julia --flag-for-julia value1 -- myscript.jl value2 --flag-for-script value3</code></pre><p>The <code>--</code> before the script name is not always necessary, but it is useful because it explicitly separates arguments passed to the Julia interpreter from arguments passed to your script.</p></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="macros/">Available Macros »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 28 December 2020 22:09">Monday 28 December 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
